/**
 * Substation Service
 * Data service for managing substation data and operations
 */

import { BaseService, ServiceConfig, ServiceError, ServiceErrorType } from './base-service'
import { 
  SubstationModel, 
  ApiResponse, 
  PaginatedResponse, 
  DataQuery,
  EntityStatus 
} from '../models/interfaces'
import { validators } from '../models/validators'

/**
 * Substation-specific query filters
 */
export interface SubstationFilters {
  zone?: string
  status?: EntityStatus[]
  redundancyGroup?: string
  redundancyLevel?: string[]
  powerRatingRange?: [number, number]
  currentLoadRange?: [number, number]
  voltageRange?: [number, number]
  temperatureRange?: [number, number]
}

/**
 * Substation creation/update data
 */
export interface SubstationCreateData {
  name: string
  type: 'PRIMARY' | 'BACKUP' | 'AUXILIARY' | 'DISTRIBUTION'
  zone: string
  position: { x: number; y: number }
  powerRating: number
  voltage: number
  frequency: number
  redundancyGroup: string
  redundancyLevel: 'N' | 'N+1' | '2N' | '2N+1'
  metadata?: Record<string, any>
}

/**
 * Substation update data (partial)
 */
export interface SubstationUpdateData extends Partial<SubstationCreateData> {
  status?: EntityStatus
  currentLoad?: number
  powerFactor?: number
  efficiency?: number
  temperature?: number
  operationalHours?: number
  reliability?: number
  availability?: number
  connections?: string[]
  backupSubstations?: string[]
  primarySubstation?: string
}

/**
 * Substation statistics
 */
export interface SubstationStats {
  total: number
  byStatus: Record<EntityStatus, number>
  byType: Record<string, number>
  byZone: Record<string, number>
  byRedundancyLevel: Record<string, number>
  totalCapacity: number
  totalLoad: number
  averageEfficiency: number
  averageReliability: number
  averageAvailability: number
  averageTemperature: number
}

/**
 * Substation service class
 */
export class SubstationService extends BaseService {
  private readonly endpoint = '/api/substations'

  constructor(config: ServiceConfig = {}) {
    super({
      baseUrl: config.baseUrl || process.env.NEXT_PUBLIC_API_BASE_URL || '',
      ...config
    })
  }

  /**
   * Get all substations with optional filtering and pagination
   */
  async getSubstations(query?: DataQuery & { filters?: SubstationFilters }): Promise<PaginatedResponse<SubstationModel>> {
    try {
      this.log('info', 'Fetching substations', query)
      
      const queryString = this.buildQueryString(query)
      const url = queryString ? `${this.endpoint}?${queryString}` : this.endpoint
      
      const response = await this.get<PaginatedResponse<SubstationModel>>(url)
      
      // Validate response data
      if (response.data) {
        response.data.forEach((substation, index) => {
          try {
            this.validateData(substation, validators.substation.validate.bind(validators.substation))
          } catch (error) {
            this.log('warn', `Invalid substation data at index ${index}`, { substation, error })
          }
        })
      }
      
      this.log('info', `Fetched ${response.data?.length || 0} substations`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to fetch substations', error)
      throw error
    }
  }

  /**
   * Get substation by ID
   */
  async getSubstation(id: string): Promise<ApiResponse<SubstationModel>> {
    try {
      this.log('info', `Fetching substation: ${id}`)
      
      const response = await this.get<ApiResponse<SubstationModel>>(`${this.endpoint}/${id}`)
      
      if (response.data) {
        this.validateData(response.data, validators.substation.validate.bind(validators.substation))
      }
      
      this.log('info', `Fetched substation: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to fetch substation: ${id}`, error)
      throw error
    }
  }

  /**
   * Create new substation
   */
  async createSubstation(data: SubstationCreateData): Promise<ApiResponse<SubstationModel>> {
    try {
      this.log('info', 'Creating substation', data)
      
      // Validate input data
      const substationData: Partial<SubstationModel> = {
        ...data,
        id: '', // Will be generated by server
        status: EntityStatus.ACTIVE,
        currentLoad: 0,
        powerFactor: 0.95,
        efficiency: 0.95,
        temperature: 25,
        operationalHours: 0,
        reliability: 0.99,
        availability: 0.99,
        connections: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
      
      const response = await this.post<ApiResponse<SubstationModel>>(this.endpoint, substationData)
      
      if (response.data) {
        this.validateData(response.data, validators.substation.validate.bind(validators.substation))
      }
      
      // Clear cache to ensure fresh data
      this.clearCache('substations')
      
      this.log('info', `Created substation: ${response.data?.id}`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to create substation', error)
      throw error
    }
  }

  /**
   * Update substation
   */
  async updateSubstation(id: string, data: SubstationUpdateData): Promise<ApiResponse<SubstationModel>> {
    try {
      this.log('info', `Updating substation: ${id}`, data)
      
      const updateData = {
        ...data,
        updatedAt: new Date().toISOString()
      }
      
      const response = await this.put<ApiResponse<SubstationModel>>(`${this.endpoint}/${id}`, updateData)
      
      if (response.data) {
        this.validateData(response.data, validators.substation.validate.bind(validators.substation))
      }
      
      // Clear cache
      this.clearCache('substations')
      this.clearCache(`substation/${id}`)
      
      this.log('info', `Updated substation: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to update substation: ${id}`, error)
      throw error
    }
  }

  /**
   * Patch substation (partial update)
   */
  async patchSubstation(id: string, data: Partial<SubstationUpdateData>): Promise<ApiResponse<SubstationModel>> {
    try {
      this.log('info', `Patching substation: ${id}`, data)
      
      const patchData = {
        ...data,
        updatedAt: new Date().toISOString()
      }
      
      const response = await this.patch<ApiResponse<SubstationModel>>(`${this.endpoint}/${id}`, patchData)
      
      if (response.data) {
        this.validateData(response.data, validators.substation.validate.bind(validators.substation))
      }
      
      // Clear cache
      this.clearCache('substations')
      this.clearCache(`substation/${id}`)
      
      this.log('info', `Patched substation: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to patch substation: ${id}`, error)
      throw error
    }
  }

  /**
   * Delete substation
   */
  async deleteSubstation(id: string): Promise<ApiResponse<boolean>> {
    try {
      this.log('info', `Deleting substation: ${id}`)
      
      const response = await this.delete<ApiResponse<boolean>>(`${this.endpoint}/${id}`)
      
      // Clear cache
      this.clearCache('substations')
      this.clearCache(`substation/${id}`)
      
      this.log('info', `Deleted substation: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to delete substation: ${id}`, error)
      throw error
    }
  }

  /**
   * Get substations by zone
   */
  async getSubstationsByZone(zone: string): Promise<ApiResponse<SubstationModel[]>> {
    try {
      this.log('info', `Fetching substations for zone: ${zone}`)
      
      const response = await this.get<ApiResponse<SubstationModel[]>>(`${this.endpoint}/zone/${zone}`)
      
      if (response.data) {
        response.data.forEach((substation, index) => {
          try {
            this.validateData(substation, validators.substation.validate.bind(validators.substation))
          } catch (error) {
            this.log('warn', `Invalid substation data at index ${index}`, { substation, error })
          }
        })
      }
      
      this.log('info', `Fetched ${response.data?.length || 0} substations for zone: ${zone}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to fetch substations for zone: ${zone}`, error)
      throw error
    }
  }

  /**
   * Get substations by redundancy group
   */
  async getSubstationsByRedundancyGroup(group: string): Promise<ApiResponse<SubstationModel[]>> {
    try {
      this.log('info', `Fetching substations for redundancy group: ${group}`)
      
      const response = await this.get<ApiResponse<SubstationModel[]>>(`${this.endpoint}/redundancy-group/${group}`)
      
      if (response.data) {
        response.data.forEach((substation, index) => {
          try {
            this.validateData(substation, validators.substation.validate.bind(validators.substation))
          } catch (error) {
            this.log('warn', `Invalid substation data at index ${index}`, { substation, error })
          }
        })
      }
      
      this.log('info', `Fetched ${response.data?.length || 0} substations for redundancy group: ${group}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to fetch substations for redundancy group: ${group}`, error)
      throw error
    }
  }

  /**
   * Get substation statistics
   */
  async getSubstationStats(): Promise<ApiResponse<SubstationStats>> {
    try {
      this.log('info', 'Fetching substation statistics')
      
      const response = await this.get<ApiResponse<SubstationStats>>(`${this.endpoint}/stats`)
      
      this.log('info', 'Fetched substation statistics')
      return response
      
    } catch (error) {
      this.log('error', 'Failed to fetch substation statistics', error)
      throw error
    }
  }

  /**
   * Update substation status
   */
  async updateSubstationStatus(id: string, status: EntityStatus): Promise<ApiResponse<SubstationModel>> {
    return this.patchSubstation(id, { status })
  }

  /**
   * Update substation load
   */
  async updateSubstationLoad(id: string, currentLoad: number): Promise<ApiResponse<SubstationModel>> {
    return this.patchSubstation(id, { currentLoad })
  }

  /**
   * Update substation temperature
   */
  async updateSubstationTemperature(id: string, temperature: number): Promise<ApiResponse<SubstationModel>> {
    return this.patchSubstation(id, { temperature })
  }

  /**
   * Add connection to substation
   */
  async addConnection(id: string, lineId: string): Promise<ApiResponse<SubstationModel>> {
    try {
      this.log('info', `Adding connection ${lineId} to substation ${id}`)
      
      const response = await this.post<ApiResponse<SubstationModel>>(
        `${this.endpoint}/${id}/connections`, 
        { lineId }
      )
      
      if (response.data) {
        this.validateData(response.data, validators.substation.validate.bind(validators.substation))
      }
      
      // Clear cache
      this.clearCache('substations')
      this.clearCache(`substation/${id}`)
      
      this.log('info', `Added connection ${lineId} to substation ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to add connection to substation: ${id}`, error)
      throw error
    }
  }

  /**
   * Remove connection from substation
   */
  async removeConnection(id: string, lineId: string): Promise<ApiResponse<SubstationModel>> {
    try {
      this.log('info', `Removing connection ${lineId} from substation ${id}`)
      
      const response = await this.delete<ApiResponse<SubstationModel>>(
        `${this.endpoint}/${id}/connections/${lineId}`
      )
      
      if (response.data) {
        this.validateData(response.data, validators.substation.validate.bind(validators.substation))
      }
      
      // Clear cache
      this.clearCache('substations')
      this.clearCache(`substation/${id}`)
      
      this.log('info', `Removed connection ${lineId} from substation ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to remove connection from substation: ${id}`, error)
      throw error
    }
  }

  /**
   * Bulk update substations
   */
  async bulkUpdateSubstations(updates: Array<{ id: string; data: SubstationUpdateData }>): Promise<ApiResponse<SubstationModel[]>> {
    try {
      this.log('info', `Bulk updating ${updates.length} substations`)
      
      const bulkData = updates.map(update => ({
        ...update,
        data: {
          ...update.data,
          updatedAt: new Date().toISOString()
        }
      }))
      
      const response = await this.put<ApiResponse<SubstationModel[]>>(`${this.endpoint}/bulk`, bulkData)
      
      if (response.data) {
        response.data.forEach((substation, index) => {
          try {
            this.validateData(substation, validators.substation.validate.bind(validators.substation))
          } catch (error) {
            this.log('warn', `Invalid substation data at index ${index}`, { substation, error })
          }
        })
      }
      
      // Clear cache
      this.clearCache('substations')
      
      this.log('info', `Bulk updated ${updates.length} substations`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to bulk update substations', error)
      throw error
    }
  }

  /**
   * Search substations by name or description
   */
  async searchSubstations(query: string, limit = 10): Promise<ApiResponse<SubstationModel[]>> {
    try {
      this.log('info', `Searching substations: ${query}`)
      
      const searchParams = new URLSearchParams({
        q: query,
        limit: limit.toString()
      })
      
      const response = await this.get<ApiResponse<SubstationModel[]>>(
        `${this.endpoint}/search?${searchParams.toString()}`
      )
      
      if (response.data) {
        response.data.forEach((substation, index) => {
          try {
            this.validateData(substation, validators.substation.validate.bind(validators.substation))
          } catch (error) {
            this.log('warn', `Invalid substation data at index ${index}`, { substation, error })
          }
        })
      }
      
      this.log('info', `Found ${response.data?.length || 0} substations matching: ${query}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to search substations: ${query}`, error)
      throw error
    }
  }

  /**
   * Get nearby substations
   */
  async getNearbySubstations(
    latitude: number, 
    longitude: number, 
    radiusKm = 10
  ): Promise<ApiResponse<SubstationModel[]>> {
    try {
      this.log('info', `Finding substations near ${latitude}, ${longitude} within ${radiusKm}km`)
      
      const params = new URLSearchParams({
        lat: latitude.toString(),
        lng: longitude.toString(),
        radius: radiusKm.toString()
      })
      
      const response = await this.get<ApiResponse<SubstationModel[]>>(
        `${this.endpoint}/nearby?${params.toString()}`
      )
      
      if (response.data) {
        response.data.forEach((substation, index) => {
          try {
            this.validateData(substation, validators.substation.validate.bind(validators.substation))
          } catch (error) {
            this.log('warn', `Invalid substation data at index ${index}`, { substation, error })
          }
        })
      }
      
      this.log('info', `Found ${response.data?.length || 0} nearby substations`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to find nearby substations', error)
      throw error
    }
  }
}