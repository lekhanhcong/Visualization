/**
 * Line Service
 * Data service for managing power line data and operations
 */

import { BaseService, ServiceConfig } from './base-service'
import { 
  LineModel, 
  ApiResponse, 
  PaginatedResponse, 
  DataQuery,
  EntityStatus,
  Coordinates 
} from '../models/interfaces'
import { validators } from '../models/validators'

/**
 * Line-specific query filters
 */
export interface LineFilters {
  status?: EntityStatus[]
  type?: ('TRANSMISSION' | 'DISTRIBUTION' | 'INTERCONNECTION')[]
  voltageRange?: [number, number]
  capacityRange?: [number, number]
  powerFlowRange?: [number, number]
  loadFactorRange?: [number, number]
  temperatureRange?: [number, number]
  fromSubstation?: string
  toSubstation?: string
  redundancyGroup?: string
}

/**
 * Line creation data
 */
export interface LineCreateData {
  name: string
  type: 'TRANSMISSION' | 'DISTRIBUTION' | 'INTERCONNECTION'
  path: Coordinates[]
  length: number
  voltage: number
  capacity: number
  impedance: {
    resistance: number
    reactance: number
  }
  fromSubstation: string
  toSubstation: string
  redundancyGroup?: string
  metadata?: Record<string, any>
}

/**
 * Line update data (partial)
 */
export interface LineUpdateData extends Partial<LineCreateData> {
  status?: EntityStatus
  powerFlow?: number
  current?: number
  temperature?: number
  loadFactor?: number
  efficiency?: number
  backupLines?: string[]
}

/**
 * Line statistics
 */
export interface LineStats {
  total: number
  byStatus: Record<EntityStatus, number>
  byType: Record<string, number>
  byVoltageLevel: Record<string, number>
  totalCapacity: number
  totalPowerFlow: number
  averageLoadFactor: number
  averageEfficiency: number
  averageTemperature: number
  overloadedLines: number
  criticalLines: number
}

/**
 * Power flow update data
 */
export interface PowerFlowUpdate {
  lineId: string
  powerFlow: number
  current: number
  loadFactor: number
  timestamp: string
}

/**
 * Line service class
 */
export class LineService extends BaseService {
  private readonly endpoint = '/api/lines'

  constructor(config: ServiceConfig = {}) {
    super({
      baseUrl: config.baseUrl || process.env.NEXT_PUBLIC_API_BASE_URL || '',
      ...config
    })
  }

  /**
   * Get all lines with optional filtering and pagination
   */
  async getLines(query?: DataQuery & { filters?: LineFilters }): Promise<PaginatedResponse<LineModel>> {
    try {
      this.log('info', 'Fetching lines', query)
      
      const queryString = this.buildQueryString(query)
      const url = queryString ? `${this.endpoint}?${queryString}` : this.endpoint
      
      const response = await this.get<PaginatedResponse<LineModel>>(url)
      
      // Validate response data
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      this.log('info', `Fetched ${response.data?.length || 0} lines`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to fetch lines', error)
      throw error
    }
  }

  /**
   * Get line by ID
   */
  async getLine(id: string): Promise<ApiResponse<LineModel>> {
    try {
      this.log('info', `Fetching line: ${id}`)
      
      const response = await this.get<ApiResponse<LineModel>>(`${this.endpoint}/${id}`)
      
      if (response.data) {
        this.validateData(response.data, validators.line.validate.bind(validators.line))
      }
      
      this.log('info', `Fetched line: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to fetch line: ${id}`, error)
      throw error
    }
  }

  /**
   * Create new line
   */
  async createLine(data: LineCreateData): Promise<ApiResponse<LineModel>> {
    try {
      this.log('info', 'Creating line', data)
      
      // Validate input data
      const lineData: Partial<LineModel> = {
        ...data,
        id: '', // Will be generated by server
        status: EntityStatus.ACTIVE,
        powerFlow: 0,
        current: 0,
        temperature: 25,
        loadFactor: 0,
        efficiency: 0.95,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
      
      const response = await this.post<ApiResponse<LineModel>>(this.endpoint, lineData)
      
      if (response.data) {
        this.validateData(response.data, validators.line.validate.bind(validators.line))
      }
      
      // Clear cache
      this.clearCache('lines')
      
      this.log('info', `Created line: ${response.data?.id}`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to create line', error)
      throw error
    }
  }

  /**
   * Update line
   */
  async updateLine(id: string, data: LineUpdateData): Promise<ApiResponse<LineModel>> {
    try {
      this.log('info', `Updating line: ${id}`, data)
      
      const updateData = {
        ...data,
        updatedAt: new Date().toISOString()
      }
      
      const response = await this.put<ApiResponse<LineModel>>(`${this.endpoint}/${id}`, updateData)
      
      if (response.data) {
        this.validateData(response.data, validators.line.validate.bind(validators.line))
      }
      
      // Clear cache
      this.clearCache('lines')
      this.clearCache(`line/${id}`)
      
      this.log('info', `Updated line: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to update line: ${id}`, error)
      throw error
    }
  }

  /**
   * Patch line (partial update)
   */
  async patchLine(id: string, data: Partial<LineUpdateData>): Promise<ApiResponse<LineModel>> {
    try {
      this.log('info', `Patching line: ${id}`, data)
      
      const patchData = {
        ...data,
        updatedAt: new Date().toISOString()
      }
      
      const response = await this.patch<ApiResponse<LineModel>>(`${this.endpoint}/${id}`, patchData)
      
      if (response.data) {
        this.validateData(response.data, validators.line.validate.bind(validators.line))
      }
      
      // Clear cache
      this.clearCache('lines')
      this.clearCache(`line/${id}`)
      
      this.log('info', `Patched line: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to patch line: ${id}`, error)
      throw error
    }
  }

  /**
   * Delete line
   */
  async deleteLine(id: string): Promise<ApiResponse<boolean>> {
    try {
      this.log('info', `Deleting line: ${id}`)
      
      const response = await this.delete<ApiResponse<boolean>>(`${this.endpoint}/${id}`)
      
      // Clear cache
      this.clearCache('lines')
      this.clearCache(`line/${id}`)
      
      this.log('info', `Deleted line: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to delete line: ${id}`, error)
      throw error
    }
  }

  /**
   * Get lines connected to a substation
   */
  async getLinesBySubstation(substationId: string): Promise<ApiResponse<LineModel[]>> {
    try {
      this.log('info', `Fetching lines for substation: ${substationId}`)
      
      const response = await this.get<ApiResponse<LineModel[]>>(`${this.endpoint}/substation/${substationId}`)
      
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      this.log('info', `Fetched ${response.data?.length || 0} lines for substation: ${substationId}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to fetch lines for substation: ${substationId}`, error)
      throw error
    }
  }

  /**
   * Get lines by redundancy group
   */
  async getLinesByRedundancyGroup(group: string): Promise<ApiResponse<LineModel[]>> {
    try {
      this.log('info', `Fetching lines for redundancy group: ${group}`)
      
      const response = await this.get<ApiResponse<LineModel[]>>(`${this.endpoint}/redundancy-group/${group}`)
      
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      this.log('info', `Fetched ${response.data?.length || 0} lines for redundancy group: ${group}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to fetch lines for redundancy group: ${group}`, error)
      throw error
    }
  }

  /**
   * Get line statistics
   */
  async getLineStats(): Promise<ApiResponse<LineStats>> {
    try {
      this.log('info', 'Fetching line statistics')
      
      const response = await this.get<ApiResponse<LineStats>>(`${this.endpoint}/stats`)
      
      this.log('info', 'Fetched line statistics')
      return response
      
    } catch (error) {
      this.log('error', 'Failed to fetch line statistics', error)
      throw error
    }
  }

  /**
   * Update line status
   */
  async updateLineStatus(id: string, status: EntityStatus): Promise<ApiResponse<LineModel>> {
    return this.patchLine(id, { status })
  }

  /**
   * Update power flow data
   */
  async updatePowerFlow(id: string, powerFlow: number, current: number): Promise<ApiResponse<LineModel>> {
    const loadFactor = current > 0 ? powerFlow / current : 0
    return this.patchLine(id, { powerFlow, current, loadFactor })
  }

  /**
   * Update line temperature
   */
  async updateLineTemperature(id: string, temperature: number): Promise<ApiResponse<LineModel>> {
    return this.patchLine(id, { temperature })
  }

  /**
   * Bulk update power flows
   */
  async bulkUpdatePowerFlows(updates: PowerFlowUpdate[]): Promise<ApiResponse<LineModel[]>> {
    try {
      this.log('info', `Bulk updating power flows for ${updates.length} lines`)
      
      const response = await this.put<ApiResponse<LineModel[]>>(`${this.endpoint}/power-flows/bulk`, updates)
      
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      // Clear cache
      this.clearCache('lines')
      
      this.log('info', `Bulk updated power flows for ${updates.length} lines`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to bulk update power flows', error)
      throw error
    }
  }

  /**
   * Get overloaded lines
   */
  async getOverloadedLines(threshold = 0.9): Promise<ApiResponse<LineModel[]>> {
    try {
      this.log('info', `Fetching overloaded lines (threshold: ${threshold})`)
      
      const params = new URLSearchParams({
        threshold: threshold.toString()
      })
      
      const response = await this.get<ApiResponse<LineModel[]>>(
        `${this.endpoint}/overloaded?${params.toString()}`
      )
      
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      this.log('info', `Found ${response.data?.length || 0} overloaded lines`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to fetch overloaded lines', error)
      throw error
    }
  }

  /**
   * Get critical lines (high risk)
   */
  async getCriticalLines(): Promise<ApiResponse<LineModel[]>> {
    try {
      this.log('info', 'Fetching critical lines')
      
      const response = await this.get<ApiResponse<LineModel[]>>(`${this.endpoint}/critical`)
      
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      this.log('info', `Found ${response.data?.length || 0} critical lines`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to fetch critical lines', error)
      throw error
    }
  }

  /**
   * Calculate line path distance
   */
  calculatePathDistance(path: Coordinates[]): number {
    if (path.length < 2) return 0
    
    let totalDistance = 0
    for (let i = 1; i < path.length; i++) {
      const prev = path[i - 1]
      const curr = path[i]
      const distance = Math.sqrt(
        Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
      )
      totalDistance += distance
    }
    
    return totalDistance
  }

  /**
   * Validate line path
   */
  validateLinePath(path: Coordinates[]): { valid: boolean; errors: string[] } {
    const errors: string[] = []
    
    if (path.length < 2) {
      errors.push('Line path must have at least 2 points')
    }
    
    // Check for duplicate consecutive points
    for (let i = 1; i < path.length; i++) {
      const prev = path[i - 1]
      const curr = path[i]
      if (prev.x === curr.x && prev.y === curr.y) {
        errors.push(`Duplicate consecutive points at index ${i}`)
      }
    }
    
    // Check for valid coordinates
    path.forEach((point, index) => {
      if (typeof point.x !== 'number' || typeof point.y !== 'number') {
        errors.push(`Invalid coordinates at index ${index}`)
      }
      if (isNaN(point.x) || isNaN(point.y)) {
        errors.push(`NaN coordinates at index ${index}`)
      }
    })
    
    return {
      valid: errors.length === 0,
      errors
    }
  }

  /**
   * Get line path optimization suggestions
   */
  async getPathOptimization(id: string): Promise<ApiResponse<{
    currentPath: Coordinates[]
    optimizedPath: Coordinates[]
    savings: {
      distance: number
      cost: number
    }
  }>> {
    try {
      this.log('info', `Getting path optimization for line: ${id}`)
      
      const response = await this.get<ApiResponse<any>>(`${this.endpoint}/${id}/optimize-path`)
      
      this.log('info', `Got path optimization for line: ${id}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to get path optimization for line: ${id}`, error)
      throw error
    }
  }

  /**
   * Search lines by name or description
   */
  async searchLines(query: string, limit = 10): Promise<ApiResponse<LineModel[]>> {
    try {
      this.log('info', `Searching lines: ${query}`)
      
      const searchParams = new URLSearchParams({
        q: query,
        limit: limit.toString()
      })
      
      const response = await this.get<ApiResponse<LineModel[]>>(
        `${this.endpoint}/search?${searchParams.toString()}`
      )
      
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      this.log('info', `Found ${response.data?.length || 0} lines matching: ${query}`)
      return response
      
    } catch (error) {
      this.log('error', `Failed to search lines: ${query}`, error)
      throw error
    }
  }

  /**
   * Get lines in geographic area
   */
  async getLinesInArea(
    bounds: { north: number; south: number; east: number; west: number }
  ): Promise<ApiResponse<LineModel[]>> {
    try {
      this.log('info', 'Finding lines in geographic area', bounds)
      
      const params = new URLSearchParams({
        north: bounds.north.toString(),
        south: bounds.south.toString(),
        east: bounds.east.toString(),
        west: bounds.west.toString()
      })
      
      const response = await this.get<ApiResponse<LineModel[]>>(
        `${this.endpoint}/area?${params.toString()}`
      )
      
      if (response.data) {
        response.data.forEach((line, index) => {
          try {
            this.validateData(line, validators.line.validate.bind(validators.line))
          } catch (error) {
            this.log('warn', `Invalid line data at index ${index}`, { line, error })
          }
        })
      }
      
      this.log('info', `Found ${response.data?.length || 0} lines in area`)
      return response
      
    } catch (error) {
      this.log('error', 'Failed to find lines in area', error)
      throw error
    }
  }
}